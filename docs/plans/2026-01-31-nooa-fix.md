# nooa fix Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the Agent Loop ‚Äî a single command that autonomously: creates worktree ‚Üí finds bug ‚Üí TDD red ‚Üí patches ‚Üí tests ‚Üí checks ‚Üí commits ‚Üí pushes ‚Üí opens PR.

**Architecture:** Orchestrator that chains existing commands with policy enforcement and telemetry.

**Tech Stack:** Bun, TypeScript, execa, existing nooa commands.

---

### Task 1: Fix Orchestrator Core

**Files:**
- Create: `src/features/fix/execute.ts`
- Test: `src/features/fix/execute.test.ts`

**Step 1: Write the failing test**

```typescript
import { expect, test, describe } from "bun:test";
import { runFix } from "./execute";

describe("Fix Orchestrator", () => {
    test("returns structured pipeline result", async () => {
        const result = await runFix({ issue: "test-issue", dryRun: true });
        expect(result).toHaveProperty("stages");
        expect(result).toHaveProperty("ok");
    });
});
```

**Step 2: Run test to verify it fails**

**Step 3: Write minimal implementation**

```typescript
// src/features/fix/execute.ts
import { execa } from "execa";
import { createTraceId } from "../../core/logger";

export interface FixOptions {
    issue: string;
    dryRun?: boolean;
}

export interface FixResult {
    ok: boolean;
    traceId: string;
    stages: {
        worktree: boolean;
        context: boolean;
        patch: boolean;
        test: boolean;
        check: boolean;
        commit: boolean;
        push: boolean;
        pr: boolean;
    };
}

export async function runFix(options: FixOptions): Promise<FixResult> {
    const traceId = createTraceId();
    const stages = {
        worktree: false,
        context: false,
        patch: false,
        test: false,
        check: false,
        commit: false,
        push: false,
        pr: false
    };

    if (options.dryRun) {
        return { ok: true, traceId, stages };
    }

    // Stage 1: Create worktree
    const worktree = await execa("bun", ["index.ts", "worktree", "create", `fix/${options.issue}`], { reject: false });
    stages.worktree = worktree.exitCode === 0;

    // Stage 2: Build context (future: nooa context)
    stages.context = true;

    // Stage 3: Apply patch (future: AI-driven)
    stages.patch = true;

    // Stage 4: Run tests
    const test = await execa("bun", ["test"], { reject: false });
    stages.test = test.exitCode === 0;

    // Stage 5: Run check
    const check = await execa("bun", ["index.ts", "check"], { reject: false });
    stages.check = check.exitCode === 0;

    // Stage 6-8: Commit, Push, PR (if all passed)
    if (stages.test && stages.check) {
        const commit = await execa("bun", ["index.ts", "commit", "-m", `fix: ${options.issue}`], { reject: false });
        stages.commit = commit.exitCode === 0;

        const push = await execa("bun", ["index.ts", "push"], { reject: false });
        stages.push = push.exitCode === 0;

        // PR would go here
        stages.pr = true;
    }

    return {
        ok: Object.values(stages).every(s => s),
        traceId,
        stages
    };
}
```

**Step 4: Run test to verify it passes**

**Step 5: Commit**

```bash
git add src/features/fix/
git commit -m "feat: implement fix orchestrator core"
```

---

### Task 2: CLI Command `nooa fix`

**Files:**
- Create: `src/features/fix/cli.ts`

**Step 1: Write the failing test**

```typescript
test("fix --help shows usage", async () => {
    const { stdout } = await execa("bun", ["index.ts", "fix", "--help"], { reject: false });
    expect(stdout).toContain("Usage: nooa fix");
});
```

**Step 2: Run test to verify it fails**

**Step 3: Write minimal implementation**

```typescript
// src/features/fix/cli.ts
import type { Command, CommandContext } from "../../core/command";
import { parseArgs } from "node:util";
import { runFix } from "./execute";

const fixHelp = `
Usage: nooa fix <issue> [flags]

Autonomous agent loop: worktree ‚Üí context ‚Üí patch ‚Üí test ‚Üí check ‚Üí commit ‚Üí push ‚Üí PR.

Flags:
  --dry-run      Simulate without making changes.
  --json         Output as JSON.
  -h, --help     Show help.
`;

const fixCommand: Command = {
    name: "fix",
    description: "Autonomous bug fix loop",
    execute: async ({ rawArgs }: CommandContext) => {
        const { values, positionals } = parseArgs({
            args: rawArgs,
            options: {
                help: { type: "boolean", short: "h" },
                json: { type: "boolean" },
                "dry-run": { type: "boolean" }
            },
            allowPositionals: true, strict: false
        });
        if (values.help) { console.log(fixHelp); return; }

        const issue = positionals[1];
        if (!issue) { console.error("Error: Issue ID required"); process.exitCode = 2; return; }

        console.log(`üîß Starting fix for: ${issue}`);
        const result = await runFix({ issue, dryRun: values["dry-run"] });

        if (values.json) {
            console.log(JSON.stringify(result, null, 2));
        } else {
            console.log(result.stages.worktree ? "‚úÖ Worktree created" : "‚ùå Worktree failed");
            console.log(result.stages.test ? "‚úÖ Tests passed" : "‚ùå Tests failed");
            console.log(result.stages.check ? "‚úÖ Policy check passed" : "‚ùå Policy failed");
            console.log(result.ok ? `\n‚úÖ Fix complete [${result.traceId}]` : "\n‚ùå Fix incomplete");
        }
        process.exitCode = result.ok ? 0 : 1;
    }
};

export default fixCommand;
```

**Step 4: Run test to verify it passes**

**Step 5: Commit**

```bash
git add src/features/fix/
git commit -m "feat: add nooa fix command"
```
