# Cron CLI Expansion Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Expand `nooa cron` from a single `add` helper into a full cron job lifecycle CLI backed by the SQLite `CronStore`, keeping behavior deterministic and documented so downstream agents can reliably schedule, inspect, and manage jobs.

**Architecture:** Build a thin `cronService` that wraps `CronStore` (create/list/update/delete) and reuse it from the CLI. The CLI will switch on subcommand + flags, delegate to the service, and surface structured text/json output while logging helpful telemetry. The store will persist jobs and allow enabling/disabling, removing, and fetching status/history data via new tables.

**Tech Stack:** Bun + TypeScript for CLI (`parseArgs`, `execa` in tests), `node:crypto` + `bun:sqlite` for persistence, docs/markdown for command reference.

### Task 1: Harden `CronStore` + Persistence Schema

**Files:**
- Modify: `src/core/db/schema/cron_jobs.ts`
- Modify: `src/core/db/cron_store.ts`
- Modify: `src/core/db/schema/cron.ts` (clean up or align to new schema)

**Step 1:** Add `cron_logs` table definition capturing `job_name`, `status`, `run_id`, `started_at`, `finished_at`, `duration_ms`, `output TEXT`, `error TEXT`. Run `setupCronJobsTable` when the store initializes to ensure both tables exist.
**Step 2:** Extend `CronStore` with methods:
- `deleteJob(name)` deletes by name and returns boolean.
- `toggleJob(name, enabled)` updates `enabled` flag.
- `updateSchedule(name, schedule)` and `updateCommand(name, command)` for `edit`/`resume` & `run` recognition.
- `recordExecution(name, status, output?, error?)` inserts into `cron_logs` and updates job `last_run_at`, `last_status`, `next_run_at` (stub next run as schedule string for now).
- `listLogs(name, limit, since)` returns rows ordered by started_at desc.
Add tests in `src/core/db/cron_store.test.ts` verifying each new method (use new Database memory). Use expectations that toggling flips `enabled` etc.
**Step 3:** Expose helper `CronStore.fromEnv()` maybe? We'll just instantiate with `new Database(process.env.NOOA_DB_PATH ?? "nooa.db")` inside service, so no plan step needed beyond doc updates.

### Task 2: Build Cron Service Layer

**Files:**
- Create: `src/features/cron/service.ts`

**Step 1:** Import `Database` + `CronStore`. Create singleton `cronService` that instantiates `CronStore` with path from `process.env.NOOA_DB_PATH || "nooa.db"` and exposes methods aligning with CLI calls: `addJob`, `listJobs`, `removeJob`, `enable`, `disable`, `recordExecution`, `getStatus`, `listLogs`, `updateJob`.
**Step 2:** Add helper `serializeJob(job)` that formats `enabled`, `last_run_at`, `next_run_at`. Provide JSON-friendly output for CLI (makes `--json` easy).
**Step 3:** Document service API with inline comments so CLI developers know expected return shape.

### Task 3: Extend CLI Command Implementation

**Files:**
- Modify: `src/features/cron/cli.ts`
- Modify: `src/features/cron/cli.test.ts`

**Step 1:** Replace `cronHelp` with a full help string covering subcommands (`add`, `list`, `remove`, `enable`, `disable`, `run`, `status`, `logs`, `edit`, `pause`, `resume`, `history`) and flags (global `--json`, `--daemon`). Keep `--` command for `add`.
**Step 2:** Parse `rawArgs` using `parseArgs` with options per command (e.g., `description`, `on-failure`, `retry`, etc.). Use `strict: false` but validate required options per command, setting `process.exitCode` to `2` on invalid input.
**Step 3:** Wire each subcommand to `cronService` methods. For `add`, call `cronService.addJob`. For `list`, call `listJobs` and print table/JSON. For `remove`, call `removeJob` and exit non-zero if job missing. For `enable/disable`, call toggle. For `status`, fetch job and show status line. For `logs/history`, call `listLogs`. For `run`, call `cronService.recordExecution` with placeholder status and show that job ran now. For `edit`, allow `--schedule`/`--command` updates. For `pause/resume`, treat same as `disable/enable` but log reason.
**Step 4:** Support `--json` flag by serializing outputs to JSON and quoting job lists. Provide success/error messages for CLI. Ensure TTL watchers (exit code 0 on success, 1 when job missing, 2 for usage errors).
**Step 5:** Use `await` where necessary (maybe CronStore methods synchronous; we just wrapping but keep asynchronous to allow future). Use `console.log` for output.

### Task 4: Add CLI Tests

**Files:**
- Modify: `src/features/cron/cli.test.ts`

**Step 1:** Use `execa` to simulate `nooa cron --help`, ensure usage printed.
**Step 2:** Run `cron add` with minimal args verifying success message, confirm `cron list` shows job (maybe using `--json` to easily assert). Use temp DB by setting `NOOA_DB_PATH` to a unique file per test.
**Step 3:** Add tests for `list --json`, `status`, `logs`, `history`, `edit`, `remove`, `run` flows.
**Step 4:** Ensure each test cleans up the temporary DB files.

### Task 5: Update Docs

**Files:**
- Modify: `docs/commands/cron.md`

**Step 1:** Replace minimal content with full help text describing each subcommand, flags, and examples from the plan. Outline global `--daemon`/`--json` flags, mention `NOOA_DB_PATH` for persistence and `.nooa/cron` structures.
**Step 2:** Mention that jobs are persisted to SQLite (via `nooa.db` or `NOOA_DB_PATH`), referencing CronStore tables and log tracking. Add section describing logs/history and how to inspect them.
**Step 3:** Link to plan doc or mention `docs/plans/2026-02-03-cron-cli.md` for implementation details (maybe in plan?).

### Task 6: Testing & Verification

**Commands:**
- `bun test src/features/cron/cli.test.ts`
- `bun lint`
- `bun check`

**Step:** Run `bun test`, `bun lint`, `bun check` at the end of development to verify the entire suite.

### Execution Options
Plan complete and saved to `docs/plans/2026-02-03-cron-cli.md`. Two execution options:
1. Subagent-Driven (this session) – use `superpowers:subagent-driven-development` and work through each plan step with checkpoints.
2. Parallel Session – run `superpowers:executing-plans` in a new session dedicated to implementing this plan.

Which approach do you want to take?
